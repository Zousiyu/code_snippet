\chapter{算法}

算法可视化的网站，\url{https://www.cs.usfca.edu/\%7Egalles/visualization/Algorithms.html}，晕乎乎的时候看几遍动画就明白了。

\section{排序}

先来了解几个基本概念：

排序：将一组“无序”的记录序列调整为“有序”的记录序列。

稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，则称这种排序算法是稳定的，否则称为不稳定的。

排序算法的分类：插入类、交换类、选择类、归并类和基数类。

基于⽐较的排序算法的最佳性能为$ O(n\log n) $。

\subsection{冒泡排序}

复杂度：$ O(n^2) $

1、对数组array[n]进行从0~n-1项的扫描，每碰到相邻两项数值大的在前小的在后时，对二者进行交换。当扫描进行完成后，0~n-1中最大的元素必然已经在array[n-1]就位，而所有数值较小，序号却靠后的元素，序号也减小了1。

2、既然最大的元素已在array[n-1]的位置就位，接下来的扫描只需从0~n-2。具体过程同1。同样的，扫描结束后0~n-2中最大的元素（全数组第二大的元素）必然已经在array[n-2]就位，而所有数值较小，序号却靠后的元素，序号也减小了1。

3、如此不断重复，直到最小的元素在array[0]的位置就位。

从上述描述中我们可以看到“冒泡排序”这个名字的由来：每一次扫描，都可以使得数值较小，序号却靠后的元素的序号减少1，宏观来看这些元素就像是从数组底部向上慢慢上浮的泡泡。

\inputminted{c++}{code/algorithm/bubble_sort.cpp}

\subsection{插入排序}

复杂度：$ O(n^2) $，具体算法描述如下：

1.从第一个元素开始，该元素可以认为已经被排序

2.取出下一个元素，在已经排序的元素序列中\textit{从后向前扫描}

3.如果该元素（已排序）大于新元素，将该元素移到下一位置

4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置

5.将新元素插入到该位置后

6.重复步骤2~5

插入排序和人们打牌时所用的排序方式类似：抽第一张牌，此时手上的牌只有一张，所以是有序的。再抽一张牌，和手上的那张牌的大小进行比较，比它大就放在后面，否则放在前面。再抽一张牌，和手上的牌进行比较，插入在合适的位置，保持手上的牌有序。不断重复，直到牌抽完。从宏观来看，插入排序把数组分割成两部分，\textit{前段有序后段无序}，随着插入排序的进行，后段无序的牌也越来越少，直到后段全部融入前段，排序也就结束了。

\inputminted{c++}{code/algorithm/insert_sort.cpp}

\subsection{归并排序}

复杂度：$ O(n\log n) $

归并排序的操作有两步，分割和归并

1、分割：将数组二等分，并将得到的子数组继续二等分，直到每个子数组只剩下一个元素为止。

2、归并：不断将原本属于同一个数组的两个子数组归并成一个有序的数组，方法为不断比较子数组的首元素，并弹出较小的放入合并后组成的数组中。直到所有子数组合并为一个数组。



\subsection{选择排序}

复杂度：$ O(n^2) $

在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

\inputminted{cpp}{code/algorithm/select_sort.cpp}

\subsection{快速排序}

复杂度：$ O(n^2) $（最坏情况）；$ O(n\log n) $（平均情况），光听名字就很快。它其采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。

1.从数列中取出一个数作为基准数（枢轴，pivot）；

2.将数组进行划分(partition)，将比基准数大的元素都移至枢轴右边，将小于等于基准数的元素都移至枢轴左边；

3.递归地（recursively）把子数列排序。

C++实现的递归版本：
\inputminted{c++}{code/algorithm/quick_sort.cpp}

Python实现的递归版本：
\inputminted{python}{code/algorithm/quick_sort.py}

问题：为什么临时储存点的索引是low-1？


